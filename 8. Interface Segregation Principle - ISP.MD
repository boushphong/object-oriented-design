## Interface Segregation Principle
- No clients should be forced to depend on methods they do not use.
- This often becomes a problem when `clients` have dependencies on what we call those fat classes (classes that have too many responsibilities)
- Having an interface to separate behavior is a good idea, and it prevents tight coupling between between the objects.

### Example

![image](https://user-images.githubusercontent.com/59940078/206358032-20de9191-2236-458b-a379-f17227cd07d1.png)

We will discuss how having an interface between `CustomerTransaction` with other 2 `Clients` of `AccountReceivable` and `ReportGenerator` could benefit the design.

In this case, The `CustomerTransaction` Object contains a lot of behavior that other `Client` modules like `AccountReceivable` and `ReportGenerator` depend on. And this transaction object is obviously unaware of these two `Clients`, because it's the clients that are pointing at it rather than it containing references to the two clients. This is a potentially unwanted `Association`. This means the `ReportGenerator` requires an instance of `CustomerTransaction`, and so does the `AccountReceivable`. But both of the clients don't require all of the behavior of the `CustomerTransaction` object has to offer.

Eg: 
- The `AccountReceivable` client only relies on functionality for charging the customer (**_chargeCustomer_**) preparing an invoice (**_prepareInvoice_**).
- The `ReportGenerator`, on the other hand, uses methods like **_getName_**, **_getDate_** and **_getProductBreakdown_**.

Problems:
Changes in the `CustomerTransaction` class could result in recompilation and redeployment of both of these dependent client modules.
- If requirement changes force us to modify **_chargeCustomer_** method to accept a new argument, the `ReportGenerator` would also be dragged into recompilation and redeployment, even though it does not use that particular method. The reason for this is because there's a direct relationship with the underlying `CustomerTransaction` object. This means that it is natural for the `AccountReceivable` Object to be recompiled and reployed, however since `ReportGenerator` has a dependency on the `CustomerTransaction`. It will also have to be recompiled and redeployed.

- The way around this is to put an interface between the objects that depend on the `CustomerTransaction` object. And only to find those methods in the interface that are specific to the particular module that is being separated by that interface.


### Solution Code

```java
import java.util.Date;
import java.util.List;


public class CustomerTransaction implements Accounting, Reporting {

    private List<Product> products;

    private Customer customer;

    public CustomerTransaction(Customer customer, List<Product> products){
        this.products= products;
        this.customer = customer;
    }

    // methods for reporting
    @Override
    public String getName(){
        return customer.getName();
    }
    
    @Override
    public Date getDate(){
        return new Date();
    }
    
    @Override
    public String productBreakDown(){
        String reportListing = null;
        for(Product product: products){
            reportListing +=product.getProductName();
        }
        return reportListing;
    }
    
    @Override
    public void prepareInvoice(){
        System.out.println("invoice prepared...");
    }
    
    @Override
    public void chargeCustomer(){
        System.out.println("charged the customer");
    }
}
```

```java
public interface Accounting {

    public void prepareInvoice();

    public void chargeCustomer();

}
```

```java
public class AccountsReceivable {

    private Accounting transactionObject;

    public AccountsReceivable(Accounting aTransaction){
        transactionObject = aTransaction;
    }
    
    public void postPayment(){
        transactionObject.chargeCustomer();
    }

    public void sendInvoice(){
        transactionObject.prepareInvoice();
        // sends the invoice
    }
}
```

```java
import java.util.Date;

public interface Reporting {

    // methods for reporting
    public String getName();

    public Date getDate();

    public String productBreakDown();

}
```

```java
public class ReportGenerator {

    private Reporting transactionObject;

    public void generateReport(){
        System.out.println(transactionObject.getName() + " "
                + transactionObject.productBreakDown() + " "
                + transactionObject.getDate());
    }
}
```

```java
public class Customer {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```java
public class Product {
    private int productId;
    private String productName;

    public int getProductId() {
        return productId;
    }
    public void setProductId(int productId) {
        this.productId = productId;
    }
    public String getProductName() {
        return productName;
    }
    public void setProductName(String productName) {
        this.productName = productName;
    }
}
```

Without the interfaces, if something changes in the `CustomerTransaction` Object, the `AccountReceivable` (let's say if this was an independent separate module) and is an application that was deployed running independently of the `CustomerTransaction`. If we change something of the `CustomerTransaction` object that is not specific to `AccountReceivable`, the `AccountReceivable` module would still have to be recompiled to get the latest code. And that sort of dependecy should not be there between these objects directly because `AccountReceivable` doesn't use all of the `CustomerTransactions` behaviour. It only uses 2 methods from the `CustomerTransaction` Object.

With the interface on the solution code, the `AccountReceivable` Class don't have to reference the `CustomerTransaction` object. It automatically wired in the accounting interface. 
```java
public class AccountsReceivable {

    private Accounting transactionObject;
    ...
}
```
So now changes in methods that are specific to reporting won't impact accounts receivable at all because it's actually referencing the transaction object `transactionObject` through an Interface definition.

With the solution code, we can clearly see the how the `Product`, `Customer` are related to `CustomerTransaction` and how `AccountReceivable`, `ReportGenerator` are related to the `CustomerTransaction` through an Interface to reduce the amount of coupling. This is the `Interface Segregation Principle` (Through the usage of Interfaces to reduce coupling).

## Take-away

`Interface Segregation Principle` is all about segregating interfaces and make them smaller. Whenever you have an Interface, you need everything that implements that Interface to use every portion of the Interface.

Eg.
- It doensn't make sense for a `Turret` Object to be able to access methods such as **_move_** even though **_move_** could be left unimplemented in the `turret` Object. Hence, the `Turret` Object should only inherit the `GameObject` interface, and not inherit the `Moveable` interface.
